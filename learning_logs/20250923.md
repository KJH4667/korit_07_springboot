Entity 클래스의 경우에는 DB에서 table역할을 함.
Entity 클래스의 field들은 column역할을 함.
JPA와 연동 되어있기 때문에 필수적으로 기본 생성자를 요구함. 
id값을 AUTO로 잡아놨기 때문에(즉, 생성될 때마다 db에서 고유 id값을 부여하기 때문에)
@AllArgsConstructor를 적용하면 오류가 발생합니다. 

## tostring의 경우 sout 한 이후 주소가 나왔다. 객체명으로만 정의하더라도  필드의 목록을 보여준다.

```java
#롬복이 적용되지 않은 예시
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.NoArgsConstructor;

@Entity
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerid;

    private String firsName, lastName;
    // Lombok 사용하지 않고, 기본 생성자 및 ownerId를 제외한 RequiredArgsConstructor를 생성할 것
    // Lombok 사용하지 않고, 각 field에 대한 getter setter를 생성할 것

    public Owner() {
    // 기본생성자
    }

    public Owner(String firsName, String lastName) {
        this.firsName = firsName;
        this.lastName = lastName;
    }



    public Long getOwnerid() {
        return ownerid;
    }

    public void setOwnerid(Long ownerid) {
        this.ownerid = ownerid;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getFirsName() {
        return firsName;
    }

    public void setFirsName(String firsName) {
        this.firsName = firsName;
    }
}

```

```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

@Entity
@Getter
@Setter
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;
    
    private final String firstName;
    
    private final String lastName;
    
}
```
- `@NoArgsConstructor(force = true)`: final 필드가 있는 경우에도 해당 필드를 null로 초기화하는 생성자를 강제로 생성해주기 때문에 final 키워드가 붙은 경우에도 JPA에서 요구되는 기본 생성자를 만들수 있고, `@RequiredArgsConstructor`와도 충돌하지 않습니다. 

## 테이블 간의 관계 추가

car 테이블과 일대다(1:N) 관계에 있는 owner 라는 새 테이블을 만들겁니다. 일대다 관계는 소유자가 한 명이 자동차 여러 대를 가질수 있지만, 한 자동차의 소유자는 한명이라는 의미입니다.

domain 패키지에 Owner이라는 엔티티 클래스와 OwnerRepository 라는 repository 인터페이스를 만들어야 합니다.그리고 OwnerREpository는 JpaREpository를 상속 받아야 합니다.

이상의 일대다 관게를 추가하려면 `@ManyToOne`과 `@OneToMany` 에너테이션(jakarta.persistence)을 이용해야 합니다. 외래 키를 포함한 Car 엔티티 클래스에서는 `@ManyToOne`을 사용할겁니다(이것 때문에 위에 부분 복사해왔습니다.) 그리고 외래키를 추가했기 때문에 field구성이 달라져야겠죠.

그럼 DB 적으로 봤을때는 car table에다가 외래키인 ownerId를 추가하는 개념이라고 볼 수 있기 때문에 Car entity class에는 Owner 관련 field를 추가해야 합니다.그렇다면 새로 field에 대한 getter / setter도 요구될겁니다. 모든 JOIN 관계에서는 FetchType.LAZY를 이용하는것이 좋습니다. 대다(toMany) 관계의 경우에는 FetchType.LAZY가 기본값이므로 정의할 필요가 없지만 대일(toOne)관계의 경우에는 반드시 명시해줘야 합니다. 

fetch Type: DB에서 데이터를 검색하는 전략을 정의. 속성값으로는 
  EAGER: 즉시 검색
  LAZY: 지연 검색
  저희 예제에서는 지연 검색(LAZY)은 DB에서 소유자를 검색하면 필요할 때 해당 소유자와 연관된 모든 자동차를 검색한다는 의미입니다. 반면 즉시 검색(EAGER)은 해당 소유자의 모든 자동차를 즉시 검색합니다. 

  ```java
  // Car.java
  package com.example.cardatabase.domain;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Data // getter, setter 지우고 @Data 넣음.
@NoArgsConstructor
@Entity

public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String brand, model, color, registrationNumber;
    private int modelYear, price;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="owner")
    private Owner owner;

    public Owner getOwner() {
        return owner;
    }

    public void setOwner(Owner owner) {
        this.owner = owner;
    }

    public Car(String brand, String model, String color, String registrationNumber, int modelYear, int price) {
        this.brand = brand;
        this.model = model;
        this.color = color;
        this.registrationNumber = registrationNumber;
        this.modelYear = modelYear;
        this.price = price;
    }

}
  ```

```java
# Owner.java
```
이상의 코드에서 `@Data`를 달아둔 경우에 일부러 겹치지만 Owner와 관련된 getter / setter를 코드로 써두었습니다. 반면에 `@Getter, @Setter`를 명시해둔 Owner 클래스에는 cars 관련 getter / setter를 안썼습니다. 당연히 프로젝트 하실 때는 setOwner() / getOwner()를 코드로 쓰실 필요가 없습니다. 

Owner class 의 `@OneToMany` 에너테이션에는 특성이 있습니다. 
1. cascade 속성은 삭제 / 업데이트시 연속 효과가 적용되는 방법을 지정합니다. 
  - ALL로 설정하게 되면 모든작업이 연속적으로 적용됩니다.
  - 예를 들어 Owner를 삭제하게 되면 그 소유자와 연결된 Car 객체들도 전부 다 삭제됩니다. 

2. mappedBy = "Owner" 속성 설정: Car 클래스 사이에 이 관계의 외래 키인 owner 필드가 존재함을 명시함.

SQL을 배운 저희가 좀 어색하게 느껴질 수 있는 것은 ownerId필드 하나만 가지고 와서 연결짓는게 아니라 Owner 클래스를 통째로 들고와서 Car에 field로 삼는다는 점입니다. 


## H2 -> MariaDB로 이식

h2 version push  합니다

